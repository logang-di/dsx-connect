# -----------------------------------------------------------------------------
# DSXâ€‘Connect Helm values (production defaults)
# - External DSXA is assumed (dsxa-scanner.enabled=false)
# - REQUIRED: set global.env.DSXCONNECT_SCANNER__SCAN_BINARY_URL to your DSXA URL
# - API/workers LOG_LEVEL default to 'info'
# - Override image tag at install time: --set-string global.image.tag=<version>
# -----------------------------------------------------------------------------
# Global settings used by all dsx-connect components
global:
  # Minimal, common env most users need to touch. Everything else is set in templates with sane defaults.
  env:
    # REQUIRED when (dsxa-scanner.enabled=false): set to your external DSXA endpoint
    DSXCONNECT_SCANNER__SCAN_BINARY_URL: "http://external-dsxa:5000/scan/binary/v2"
    # Results/stats DB URL (redis://... => Redis, anything else => in-memory)
    DSXCONNECT_RESULTS_DB: redis://redis:6379/3

  # Optional shared image defaults (components fall back to these when set)
  image:
    repository: dsxconnect/dsx-connect
    tag: ""
    pullPolicy: IfNotPresent
    # Note: When installing from an OCI chart with --version=X.Y.Z, the default image tag will be that chart's appVersion.

  # Optional scanner service hints used when the dsxa-scanner dependency is enabled
  scanner:
    # serviceName: "dsxa-scanner"   # optional: explicit K8s service name (defaults to <release>-dsxa-scanner)
    # port: 5000                     # optional: override port (defaults to 5000)
    # scheme: http                   # optional: http|https (defaults to http)

# typical deployments would have dsxa-scanners in their own cluster and namespace, but for if all that's needed
# is a single dsxa-scanner pod that only supports scan/binary/v2 (file size <= 2GB), then enable here.
dsxa-scanner:
  enabled: false

dsx-connect-api:
  enabled: true
  service:
    port: 80
    # type: ClusterIP
  tls:
    enabled: false
    # secretName: ""           # defaults to <release>-dsx-connect-api-tls when enabled
  env:
    LOG_LEVEL: info
  auth:
    enabled: true
    # Provide the enrollment Secret name via dsx_connect/deploy/helm/examples/secrets/auth-enrollment-secret.yaml.
    # Leave value unset in production so the chart references your Secret instead.
    enrollment:
      key: ENROLLMENT_TOKEN

dsx-connect-scan-request-worker:
  enabled: true
  replicaCount: 1
  env:
    LOG_LEVEL: info
  celery:
    # queue: "dev.dsx_connect.scans.request"
    concurrency: 1

dsx-connect-verdict-action-worker:
  enabled: true
  replicaCount: 1
  env:
    LOG_LEVEL: info
  celery:
    # queue: "dev.dsx_connect.scans.verdict"
    concurrency: 1

dsx-connect-results-worker:
  enabled: true
  replicaCount: 1
  env:
    LOG_LEVEL: info
    DSX_WORKER_ROLE: results
    DSXCONNECT_SYSLOG__TRANSPORT: tcp
  celery:
    # queue: "dev.dsx_connect.scans.result"
    concurrency: 1

dsx-connect-notification-worker:
  enabled: true
  replicaCount: 1
  # image:
  env:
    LOG_LEVEL: info
  celery:
    # queue: "dev.dsx_connect.scans.result.notify"
    concurrency: 1

dsx-connect-dianna-worker:
  enabled: true
  replicaCount: 1
  env:
    LOG_LEVEL: info
  celery:
    # queue: "dev.dsx_connect.analyze.dianna"
    concurrency: 1
  dianna:
    # Optionally set these inline, or supply a Secret (see examples/secrets/di-api-secret.yaml) and reference it via global.dianna.secretName.
    # managementUrl: "https://di.example.com"
    # apiToken: "<token>"
    # additional DIANNA worker settings
    # verifyTls: true
    # caBundle: ""
    # chunkSize: 4194304
    # timeout: 60
    # autoOnMalicious: false
    # pollResultsEnabled: true
    # pollIntervalSeconds: 5
    # pollTimeoutSeconds: 900

redis:
  enabled: true
  image:
    repository: redis
    tag: "7-alpine"
  # For advanced tuning (command flags, probes, resources), see charts/redis/values.yaml.

rsyslog:
  enabled: true
  # For advanced tuning, see charts/rsyslog/values.yaml.

ingress:
  enabled: false
  host: "dsx-connect.127.0.0.1.nip.io"
  ingressClassName: ""
  # For TLS, the secret must be created separately (e.g., kubectl create secret tls my-ingress-tls --cert=... --key=...)
  # and its name should be specified in the dsx-connect-api.tls.secretName if it's the same secret.
  # If you have a separate secret for Ingress, specify it here:
  # tlsSecretName: ""
