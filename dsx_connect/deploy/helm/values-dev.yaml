# -----------------------------------------------------------------------------
# DSX‑Connect Helm values (developer defaults)
# - In‑cluster DSXA enabled for convenience (dsxa-scanner.enabled=true)
# - global.env.DSXCONNECT_SCANNER__SCAN_BINARY_URL usually left commented
# - API/workers LOG_LEVEL set to 'debug'
# - Override image tag at install time: --set-string global.image.tag=<version>
# -----------------------------------------------------------------------------
# Global settings used by all dsx-connect subcharts
global:
  # Minimal, common env most users need to touch. Everything else is set in templates with sane defaults.
  env:
    # For in-cluster DSXA (dsxa-scanner.enabled=true), keep this empty so templates compute the service URL.
    DSXCONNECT_SCANNER__SCAN_BINARY_URL: ""

  # DIANNA settings moved to dsx-connect-dianna-worker.dianna

  # Optional shared image defaults (subcharts fall back to these when set)
  image:
    repository: dsxconnect/dsx-connect
    tag: ""
    pullPolicy: IfNotPresent
    # Note: When installing from an OCI chart with --version=X.Y.Z, the default image tag will be that chart's appVersion.

  # Optional scanner service hints used when dsxa-scanner subchart is enabled
  scanner:
  # serviceName: "dsxa-scanner"   # optional: explicit K8s service name (defaults to <release>-dsxa-scanner)
  # port: 5000                     # optional: override port (defaults to 5000)
  # scheme: http                   # optional: http|https (defaults to http)

# typical deployments would have dsxa-scanners in their own cluster and namespace, but for if all that's needed
# is a single dsxa-scanner pod that only supports scan/binary/v2 (file size <= 2GB), then enable here.
dsxa-scanner:
  enabled: true

dsx-connect-api:
  enabled: true
  service:
    port: 80
  tls:
    enabled: false
    secretName: ""
  env:
    LOG_LEVEL: debug

dsx-connect-scan-request-worker:
  enabled: true
  replicaCount: 1
  env:
    LOG_LEVEL: debug
  celery:
    # Queue defaults to "dev.dsx_connect.scans.request"; override if sharing a broker
    # queue: "dev.dsx_connect.scans.request"
    # Concurrency = Celery workers per pod. Combine with replicaCount for total parallelism.
    concurrency: 1

dsx-connect-verdict-action-worker:
  enabled: true
  replicaCount: 1
  env:
    LOG_LEVEL: debug
  celery:
    # queue: "dev.dsx_connect.scans.verdict"
    # Concurrency = Celery workers per pod.
    concurrency: 1

dsx-connect-results-worker:
  enabled: true
  replicaCount: 1
  env:
    LOG_LEVEL: debug
    DSX_WORKER_ROLE: results
    DSXCONNECT_SYSLOG__TRANSPORT: tcp
  celery:
    # queue: "dev.dsx_connect.scans.result"
    # Concurrency = Celery workers per pod.
    concurrency: 1

dsx-connect-notification-worker:
  enabled: true
  replicaCount: 1
  # image:
  env:
    LOG_LEVEL: debug
  celery:
    # queue: "dev.dsx_connect.scans.result.notify"
    # Concurrency = Celery workers per pod.
    concurrency: 1

dsx-connect-dianna-worker:
  enabled: true
  replicaCount: 1
  env:
    LOG_LEVEL: debug
  celery:
    # queue: "dev.dsx_connect.analyze.dianna"
    # Concurrency = Celery workers per pod.
    concurrency: 1

redis:
  enabled: true
  image:
    repository: redis
    tag: "7-alpine"
  command:
    - "redis-server"
    - "--notify-keyspace-events"
    - "Ex"
    - "--maxmemory-policy"
    - "allkeys-lru"
    - "--timeout"
    - "0"
    - "--tcp-keepalive"
    - "300"
    - "--appendonly"
    - "no"
  healthcheck:
    test: ["redis-cli", "ping"]
    interval: 10
    timeout: 3
    retries: 5
    startPeriod: 10

rsyslog:
  enabled: true

ingress:
  enabled: false
  host: "dsx-connect.127.0.0.1.nip.io"
  ingressClassName: ""
  # For TLS, the secret must be created separately (e.g., kubectl create secret tls my-ingress-tls --cert=... --key=...)
  # and its name should be specified in the dsx-connect-api.tls.secretName if it's the same secret.
  # If you have a separate secret for Ingress, specify it here:
  # tlsSecretName: ""
